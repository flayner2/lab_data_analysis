"""
A Python script to parse the results of an alignment produced by running `swat`.
It parses both a .alignment and a .allscores file. A .alignment file can be produced by
redirecting `swat`'s STDOUT to a file.
"""
import sys
from collections import defaultdict


class Record:
    """Base Class for Record type objects."""

    def __init__(self) -> None:
        raise NotImplementedError


class Parser:
    """Base Class for Parser type objects."""

    def __init__(self) -> None:
        raise NotImplementedError


class AlignmentRecord(Record):
    """A Record containing information about its alignment against another subject
    sequence."""

    def __init__(self, id: str, raw_score: int, z_score: float, subject: str) -> None:
        """Instantiates an AlignmentRecord object with metrics describing its alignment
        score.

        Args:
            id (str): the sequence identifier for the particular sequence that was
            aligned.
            raw_score (int): the raw alignment score for the sequence.
            z_score (float): the corrected alignment z-score for the sequence.
            subject (str): the subject which this sequence was aligned against.
        """
        self.id = id
        self.raw_score = raw_score
        self.z_score = z_score
        self.subject = subject
        self.al_positions = []

    def set_alignment_positions(self, positions: tuple[int]) -> None:
        """Sets the indexes corresponding to the starting and ending positions of an
        alignment, where the subject is aligned with the sequence.

        Args:
            positions (tuple[int]): a 2-tuple containing the (start, end) alignment
            positions for a particular alignment for a given sequence.
        """
        self.al_positions.append(positions)


class SwatParser(Parser):
    """A Parser for swat alignment output files, which can also calculate metrics such
    as the start and end position of a particular sequence's alignment.
    """

    @staticmethod
    def parse_swat_allscores(
        allscores_file: str, subject: str = "None"
    ) -> list[AlignmentRecord]:
        """Parses a swat .allscores output file generated by running `swat` with the
        `-file` flag.

        Args:
            allscores_file (str): the path to a `swat` .allscores file.
            subject (str, optional): the subject the sequence was aligned against.
            Defaults to the string "None".

        Returns:
            list[AlignmentRecord]: a list containing an AlignmentRecord for each entry
            in the .allscores file.
        """
        result_records = []

        with open(allscores_file, "r") as scores_file:
            # Each alignment record is a separate line in the swat .allscores file
            raw_records = [line.strip() for line in scores_file.readlines()]

            for record in raw_records:
                # For each record, each column is separated by multiple spaces.
                record = record.split()
                # We only care about columns 0 (id), 2 (raw score) and 3 (z-score).
                # Everything is read as strings, so we need to convert columns 2 and 3.
                result_records.append(
                    AlignmentRecord(
                        id=record[0],
                        raw_score=int(record[2]),
                        z_score=float(record[3]),
                        subject=subject,
                    )
                )

        return result_records

    @staticmethod
    def parse_swat_alignment_output(
        alignment_file: str,
        separator_string: str = "Matches ranked by decreasing z-scores:",
    ) -> defaultdict[str, list[tuple[int, int]]]:
        """Parses a file containing the `swat` alignment output. This output is by
        default redirected to STDOUT, so you'll have to redirect the STDOUT to a file
        when running `swat` to generate such files.

        Args:
            alignment_file (str): the path to a file containing a `swat` alignment
            output.
            separator_string (str): the string used to perform the file splitting.
            By default, it's the expected string for a swat output ordered by z-scores.
            If there aren't enough positives in the output, the ordering will be by
            raw scores, so a different string will be needed for the correct splitting.
            Check your swat outputs for that. It will look like this:

            `Matches ranked by decreasing z-scores:`

            or

            `Matches ranked by decreasing raw alignment scores:`

            This is where the splitting must be performed, so look for that in your
            swat output. The clue is that it will always be followed by two blank lines
            and an alignment like:

            `Matches ranked by decreasing z-scores:`


            `EE143615.1 SiJWD03BCY2 Lausanne fire ant library Solenopsis invicta cDNA,
            mRNA sequence  Length: 420`
            `Score: 124  z: 54.40  E: 3.54e-27  new_E: 2.16e-43`

            `Subject   257 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 306`
                          `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`
            `Query       1 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 50`

            `Subject   307 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 356`
                        `AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA`
            `Query      51 AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA 100`

            `Subject   357 AAAAAAAAAAAAAAAAAAAAAAAA 380`
                        `AAAAAAAAAAAAAAAAAAAAAAAA`
            `Query     101 AAAAAAAAAAAAAAAAAAAAAAAA 124`

            For now though, files that are ordered by raw alignment score have some
            other particularities about how blocks of alignments are separated from
            each other, so this feature is not fully functional on its own yet.

        Returns:
            defaultdict[str, list[tuple[int, int]]]: a dictionary where the keys are
            sequence IDs and the values is a list of tuples containing the (start, end)
            positions of each alignment since there may be > 1 alignment for a given
            sequence.
        """
        result_positions = defaultdict(list)

        with open(alignment_file, "r") as alignments_file:
            entire_file = alignments_file.read()

            # This sentence is where the alignments start in the swat output
            _, sep, all_alignments = entire_file.partition(separator_string)

            # So we do a small check to see if this sentence is in the file
            if sep == "":
                sys.exit(
                    (
                        f"Separator string '{separator_string}' wasn't found in input"
                        "file. Check if your file contains the swat alignment results"
                        "or that your separator exists in the file."
                    )
                )

            # If everything is fine, we proceed
            # Each alignment record is separated from the next one by two blank lines
            all_alignments = all_alignments.strip().split("\n\n\n")

            for each_alignment in all_alignments:
                # Each alignment block of a record is separated from the next one by
                # one blank line
                alignment_details = each_alignment.split("\n\n")

                # The first alignment block should actually be a description of the
                # sequence, so we'll get the id from there. If we split it by spaces,
                # then the first object will be the sequence id. We pop the first block
                # because it makes it easier to process the next ones
                seq_id = alignment_details.pop(0).split()[0]

                # All alignment blocks have a Subject and a Query sequence. This is
                # just a sanitization check
                alignment_blocks = [
                    alignment_block
                    for alignment_block in alignment_details
                    if ("Subject" in alignment_block and "Query" in alignment_block)
                ]

                # If we found no alignment blocks then something is wrong
                if len(alignment_blocks) == 0:
                    sys.exit("No alignment blocks were found")

                # We only care about the first and the last alignment blocks because
                # that's where the start and end positions are, respectively. Each
                # sequence is separated from the next one by a line break. The Query
                # sequence is in the first line, and that's the one we want. If we
                # split it by spaces, the start position is the second object and the
                # end position is the last object from the first line of the last block
                start = int(alignment_blocks[0].split("\n")[0].split()[1])
                end = int(alignment_blocks[-1].split("\n")[0].split()[-1])

                # Now we are done with this sequence, so put it into the dict
                result_positions[seq_id].append((start, end))

        return result_positions
